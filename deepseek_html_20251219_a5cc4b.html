<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preliminary Framing Plan Calculator</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f7fa;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 25px 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        header p {
            font-size: 16px;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
        }
        
        .input-section {
            flex: 1;
            min-width: 350px;
            padding: 20px;
            border-right: 1px solid #eee;
        }
        
        .output-section {
            flex: 2;
            min-width: 500px;
            padding: 20px;
        }
        
        .section-title {
            font-size: 20px;
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light-color);
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        input, select {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: border 0.3s;
        }
        
        input:focus, select:focus {
            border-color: var(--secondary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            cursor: help;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: var(--dark-color);
            color: white;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: normal;
            font-size: 14px;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: var(--dark-color) transparent transparent transparent;
        }
        
        button {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 14px 25px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: 600;
            width: 100%;
            margin-top: 10px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .results-container {
            margin-top: 20px;
        }
        
        .results-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            border-bottom: 3px solid var(--secondary-color);
            color: var(--secondary-color);
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        .results-table th, .results-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        
        .results-table th {
            background-color: var(--light-color);
            font-weight: 600;
        }
        
        .results-table tr:hover {
            background-color: #f9f9f9;
        }
        
        .sketch-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            background: white;
            text-align: center;
            position: relative;
            min-height: 300px;
        }
        
        .sketch-title {
            font-size: 18px;
            margin-bottom: 15px;
            color: var(--primary-color);
        }
        
        .calculation-steps {
            background: #f9f9f9;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .input-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .input-row .input-group {
            flex: 1;
            margin-bottom: 0;
        }
        
        .input-hint {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            font-style: italic;
        }
        
        .formula {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            border-left: 3px solid var(--warning-color);
        }
        
        .calculation-step {
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-left: 4px solid var(--secondary-color);
            border-radius: 0 5px 5px 0;
        }
        
        .code-reference {
            font-size: 12px;
            color: var(--primary-color);
            font-style: italic;
            margin-top: 5px;
        }
        
        .subsection {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary-color);
        }
        
        .subsection-title {
            font-size: 16px;
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .loading {
            cursor: wait;
        }
        
        .loading * {
            cursor: wait !important;
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .export-buttons button {
            margin-top: 0;
        }
        
        @media (max-width: 768px) {
            .content {
                flex-direction: column;
            }
            
            .input-section {
                border-right: none;
                border-bottom: 1px solid #eee;
            }
            
            .input-row {
                flex-direction: column;
                gap: 0;
            }
            
            .export-buttons {
                flex-direction: column;
            }
        }
        
        .warning-message {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .note {
            font-size: 12px;
            color: #666;
            font-style: italic;
            margin-top: 5px;
        }
        
        .canvas-container {
            width: 100%;
            overflow-x: auto;
        }
        
        .sketch-canvas {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 0 auto;
        }
        
        .status-ok {
            color: var(--success-color);
            font-weight: bold;
        }
        
        .status-warning {
            color: var(--warning-color);
            font-weight: bold;
        }
        
        .status-error {
            color: var(--danger-color);
            font-weight: bold;
        }
        
        .status-info {
            color: var(--secondary-color);
            font-weight: bold;
        }
        
        .iteration-info {
            font-size: 11px;
            color: #666;
            display: block;
            margin-top: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Preliminary Framing Plan Calculator</h1>
            <p>This tool provides a preliminary framing plan with ULS sizing for slabs, beams, and columns per Hong Kong Code of Practice for Structural Use of Concrete 2013 (2020 Edition).</p>
        </header>
        
        <div class="content">
            <div class="input-section">
                <h2 class="section-title">Input Parameters</h2>
                
                <div class="subsection">
                    <div class="subsection-title">Structural Geometry</div>
                    
                    <div class="input-row">
                        <div class="input-group">
                            <label for="bayX">
                                Bay Size X (m)
                                <span class="tooltip">ℹ️
                                    <span class="tooltiptext">Horizontal bay dimension (e.g., 4-8 m typical)</span>
                                </span>
                            </label>
                            <input type="number" id="bayX" step="0.1" min="0.1" value="6.0" required>
                            <div class="input-hint">Typical range: 4-8 m</div>
                        </div>
                        
                        <div class="input-group">
                            <label for="bayY">
                                Bay Size Y (m)
                                <span class="tooltip">ℹ️
                                    <span class="tooltiptext">Vertical bay dimension (e.g., 4-8 m typical)</span>
                                </span>
                            </label>
                            <input type="number" id="bayY" step="0.1" min="0.1" value="6.0" required>
                            <div class="input-hint">Typical range: 4-8 m</div>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="maxSpan">
                            Maximum Slab Span (m)
                            <span class="tooltip">ℹ️
                                <span class="tooltiptext">Max span for one-way slabs; set equal to bay size for two-way</span>
                            </span>
                        </label>
                        <input type="number" id="maxSpan" step="0.1" min="0.1" value="6.0" required>
                        <div class="input-hint">Controls secondary beam spacing</div>
                    </div>
                    
                    <div class="input-row">
                        <div class="input-group">
                            <label for="slabType">
                                Slab Type
                                <span class="tooltip">ℹ️
                                    <span class="tooltiptext">Two-way for square bays; one-way for long, narrow bays</span>
                                </span>
                            </label>
                            <select id="slabType">
                                <option value="two-way" selected>Two-way</option>
                                <option value="one-way">One-way</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="spanDirection">
                                Span Direction
                                <span class="tooltip">ℹ️
                                    <span class="tooltiptext">Direction of main slab span (relevant for one-way slabs)</span>
                                </span>
                            </label>
                            <select id="spanDirection">
                                <option value="alongX">Along X</option>
                                <option value="alongY">Along Y</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="subsection">
                    <div class="subsection-title">Loading Conditions</div>
                    
                    <div class="input-group">
                        <label for="liveLoad">Live Load Class - per Table 3.1, HK Code 2011</label>
                        <select id="liveLoad">
                            <option value="">Select Class</option>
                            <option value="1">Class 1: Domestic and residential floors</option>
                            <option value="2" selected>Class 2: Offices and non-industrial workplaces</option>
                            <option value="3">Class 3: Areas where people congregate</option>
                            <option value="4">Class 4: Shopping areas</option>
                            <option value="5">Class 5: Storage and industrial uses</option>
                            <option value="6">Class 6: Vehicular traffic areas</option>
                            <option value="7">Class 7: Roofs</option>
                            <option value="8">Class 8: Affiliated building elements</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="liveLoadSub">Live Load Sub-Division - per Table 3.2, HK Code 2011</label>
                        <select id="liveLoadSub">
                            <option value="">Select Sub-Division</option>
                        </select>
                    </div>
                    
                    <div class="input-group" id="heightInput" style="display: none;">
                        <label for="height">
                            Storage Height (m) for Height-Dependent Loads
                            <span class="tooltip">ℹ️
                                <span class="tooltiptext">Height for storage loads (Class 5 only)</span>
                            </span>
                        </label>
                        <input type="number" id="height" step="0.1" min="0.1" value="3.0" placeholder="Enter height if applicable">
                    </div>
                    
                    <div class="input-group">
                        <label for="deadLoad">
                            Superimposed Dead Load (kPa)
                            <span class="tooltip">ℹ️
                                <span class="tooltiptext">Additional dead load (e.g., finishes, 1-3 kPa)</span>
                            </span>
                        </label>
                        <input type="number" id="deadLoad" step="0.1" min="0" value="2.0" required>
                        <div class="input-hint">Typical range: 1-3 kPa for finishes</div>
                    </div>
                    
                    <div class="input-group">
                        <label for="floors">
                            Number of Floors (for column load est.)
                            <span class="tooltip">ℹ️
                                <span class="tooltiptext">Total floors supported by columns</span>
                            </span>
                        </label>
                        <input type="number" id="floors" step="1" min="1" value="5" required>
                    </div>
                </div>
                
                <div class="subsection">
                    <div class="subsection-title">Material Properties</div>
                    
                    <div class="input-row">
                        <div class="input-group">
                            <label for="concreteSlab">Concrete Grade - Slab (MPa)</label>
                            <select id="concreteSlab">
                                <option value="25">25</option>
                                <option value="30">30</option>
                                <option value="35" selected>35</option>
                                <option value="40">40</option>
                                <option value="45">45</option>
                                <option value="50">50</option>
                                <option value="55">55</option>
                                <option value="60">60</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="concreteBeam">Concrete Grade - Beams (MPa)</label>
                            <select id="concreteBeam">
                                <option value="30">30</option>
                                <option value="35">35</option>
                                <option value="40" selected>40</option>
                                <option value="45">45</option>
                                <option value="50">50</option>
                                <option value="55">55</option>
                                <option value="60">60</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="concreteColumn">Concrete Grade - Columns (MPa)</label>
                        <select id="concreteColumn">
                            <option value="35">35</option>
                            <option value="40">40</option>
                            <option value="45" selected>45</option>
                            <option value="50">50</option>
                            <option value="55">55</option>
                            <option value="60">60</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="exposure">Exposure Condition - per Table 4.1</label>
                        <select id="exposure">
                            <option value="1">1 - Mild</option>
                            <option value="2" selected>2 - Moderate</option>
                            <option value="3">3 - Severe</option>
                            <option value="4">4 - Very Severe</option>
                            <option value="5">5 - Abrasive</option>
                        </select>
                    </div>
                </div>
                
                <div class="subsection">
                    <div class="subsection-title">Reinforcement Parameters</div>
                    
                    <div class="input-row">
                        <div class="input-group">
                            <label for="minReinforcementSlab">
                                Min Reinforcement - Slab (%)
                                <span class="tooltip">ℹ️
                                    <span class="tooltiptext">Typically 0.13-1.0% per HK Code</span>
                                </span>
                            </label>
                            <select id="minReinforcementSlab">
                                <option value="0.13">0.13</option>
                                <option value="0.2">0.2</option>
                                <option value="0.5" selected>0.5</option>
                                <option value="1.0">1.0</option>
                            </select>
                        </div>
                        
                        <div class="input-group">
                            <label for="maxReinforcementBeam">
                                Max Reinforcement - Beams (%)
                                <span class="tooltip">ℹ️
                                    <span class="tooltiptext">Typically 2.0-4.0% per HK Code</span>
                                </span>
                            </label>
                            <input type="number" id="maxReinforcementBeam" step="0.1" min="1.0" max="6.0" value="2.5">
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="minReinforcementBeam">
                            Min Reinforcement - Beams (%)
                            <span class="tooltip">ℹ️
                                <span class="tooltiptext">Typically 0.13-1.0% per HK Code</span>
                            </span>
                        </label>
                        <select id="minReinforcementBeam">
                            <option value="0.13">0.13</option>
                            <option value="0.2">0.2</option>
                            <option value="0.5">0.5</option>
                            <option value="1.0" selected>1.0</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="minReinforcement">
                            Min Reinforcement - Columns (%)
                            <span class="tooltip">ℹ️
                                <span class="tooltiptext">0.4-6.0% per HK Code for columns</span>
                            </span>
                        </label>
                        <select id="minReinforcement">
                            <option value="0.8">0.8</option>
                            <option value="1.0">1.0</option>
                            <option value="1.5">1.5</option>
                            <option value="2.0" selected>2.0</option>
                            <option value="3.0">3.0</option>
                            <option value="4.0">4.0</option>
                        </select>
                    </div>
                </div>
                
                <button onclick="calculateFraming()" id="calculateBtn">Calculate Framing Plan</button>
                
                <div class="export-buttons">
                    <button onclick="exportResults()" style="background: var(--primary-color);">Export Data</button>
                    <button onclick="generateReport()" style="background: var(--success-color);">Generate Report</button>
                </div>
            </div>
            
            <div class="output-section">
                <h2 class="section-title">Results</h2>
                
                <div class="results-container">
                    <div class="results-tabs">
                        <div class="tab active" onclick="switchTab('summary')">Summary</div>
                        <div class="tab" onclick="switchTab('calculations')">Calculations</div>
                    </div>
                    
                    <div id="summary" class="tab-content active">
                        <h3>Design Summary</h3>
                        <table class="results-table">
                            <thead>
                                <tr>
                                    <th>Element</th>
                                    <th>Size</th>
                                    <th>Reinforcement</th>
                                    <th>Moment (kNm)</th>
                                    <th>Shear (kN)</th>
                                    <th>Check</th>
                                </tr>
                            </thead>
                            <tbody id="summaryTableBody">
                                <tr><td colspan="6" style="text-align: center;">Click "Calculate Framing Plan" to see results</td></tr>
                            </tbody>
                        </table>
                        
                        <div class="sketch-container">
                            <div class="sketch-title">Preliminary Framing Plan</div>
                            <div class="canvas-container">
                                <canvas id="framingChart" class="sketch-canvas"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <div id="calculations" class="tab-content">
                        <h3>Detailed Calculations</h3>
                        <div class="calculation-steps" id="calculationSteps">
                            <div style="text-align: center; padding: 20px; color: #666;">
                                Detailed calculations will appear here after running the analysis
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Concrete density constant
        const CONCRETE_DENSITY = 24.5; // kN/m³
        const STEEL_YIELD_STRENGTH = 460; // MPa for Grade 500
        const LINK_YIELD_STRENGTH = 250; // MPa for Grade 250 links

        // Live load sub-divisions data
        const subDivisions = {
            '1': [
                { value: '1.1', text: 'Domestic uses - 2.0 kPa', qk: 2.0 },
                { value: '1.2', text: 'Dormitories - 2.0 kPa', qk: 2.0 },
                { value: '1.3', text: 'Hotel rooms - 2.0 kPa', qk: 2.0 },
                { value: '1.4', text: 'Hospital wards - 2.0 kPa', qk: 2.0 },
                { value: '1.5', text: 'Bathrooms - 2.0 kPa', qk: 2.0 },
                { value: '1.6', text: 'Pantries - 2.0 kPa', qk: 2.0 },
                { value: '1.7', text: 'Kitchens - 2.0 kPa', qk: 2.0 }
            ],
            '2': [
                { value: '2.1', text: 'Medical consulting rooms - 2.5 kPa', qk: 2.5 },
                { value: '2.2', text: 'Hospital operating theatres - 2.5 kPa', qk: 2.5 },
                { value: '2.3', text: 'Laboratories - 3.0 kPa', qk: 3.0 },
                { value: '2.4', text: 'Light workrooms - 3.0 kPa', qk: 3.0 },
                { value: '2.5', text: 'Offices for general use - 3.0 kPa', qk: 3.0 },
                { value: '2.6', text: 'Electrical installations - 3.0 kPa', qk: 3.0 },
                { value: '2.7', text: 'Meter rooms - 3.0 kPa', qk: 3.0 },
                { value: '2.8', text: 'Pantries - 3.0 kPa', qk: 3.0 },
                { value: '2.9', text: 'Banking halls - 4.0 kPa', qk: 4.0 },
                { value: '2.10', text: 'Kitchens and laundries - 4.0 kPa', qk: 4.0 },
                { value: '2.11', text: 'Projection rooms - 5.0 kPa', qk: 5.0 }
            ],
            '3': [
                { value: '3.1', text: 'Childcare centers - 2.5 kPa', qk: 2.5 },
                { value: '3.2', text: 'Classrooms - 3.0 kPa', qk: 3.0 },
                { value: '3.3', text: 'Computer rooms - 3.0 kPa', qk: 3.0 },
                { value: '3.4', text: 'Recreational areas - 3.0 kPa', qk: 3.0 },
                { value: '3.5', text: 'Massage rooms - 3.0 kPa', qk: 3.0 },
                { value: '3.6', text: 'Reading rooms - 3.0 kPa', qk: 3.0 },
                { value: '3.7', text: 'Cafes and amusement centers - 4.0 kPa', qk: 4.0 },
                { value: '3.8', text: 'Restaurants and bars - 4.0 kPa', qk: 4.0 }
            ],
            '4': [
                { value: '4.1', text: 'Department stores and shops - 5.0 kPa', qk: 5.0 }
            ],
            '5': [
                { value: '5.1', text: 'Library rooms - 5.0 kPa', qk: 5.0 },
                { value: '5.2', text: 'Offices for storage - 5.0 kPa', qk: 5.0 },
                { value: '5.3', text: 'Refuse storage - 2.5 per m height kPa', isHeight: true, perM: 2.5, min: null },
                { value: '5.4', text: 'Stack rooms - 3.5 per m height, min 10.0 kPa', isHeight: true, perM: 3.5, min: 10.0 },
                { value: '5.5', text: 'Cold storage - 5.0 per m height, min 15.0 kPa', isHeight: true, perM: 5.0, min: 15.0 },
                { value: '5.6', text: 'Paper storage - 8.0 per m height kPa', isHeight: true, perM: 8.0, min: null },
                { value: '5.7', text: 'Battery rooms - 10.0 per m height kPa', isHeight: true, perM: 10.0, min: null },
                { value: '5.8', text: 'General storage - 2.5 per m height kPa', isHeight: true, perM: 2.5, min: null },
                { value: '5.9', text: 'Plant rooms - 7.5 kPa', qk: 7.5 },
                { value: '5.10', text: 'Light workshops - 5.0 kPa', qk: 5.0 },
                { value: '5.11', text: 'Medium workshops - 7.5 kPa', qk: 7.5 },
                { value: '5.12', text: 'Heavy workshops - 10.0 kPa', qk: 10.0 }
            ],
            '6': [
                { value: '6.1', text: 'Areas for vehicular traffic - 5.0 kPa', qk: 5.0 }
            ],
            '7': [
                { value: '7.1', text: 'Roofs (slope ≤ 5°) - 2.0 kPa', qk: 2.0 },
                { value: '7.2', text: 'Roofs (5° < slope ≤ 20°) - 0.75 kPa', qk: 0.75 },
                { value: '7.3', text: 'Roofs (20° < slope < 40°) - 0.375 kPa', qk: 0.375 },
                { value: '7.4', text: 'Roofs (slope ≥ 40°) - 0 kPa', qk: 0 },
                { value: '7.5', text: 'Roofs with access - 2.0 kPa', qk: 2.0 },
                { value: '7.6', text: 'Lightweight canopy - 0.75 kPa', qk: 0.75 },
                { value: '7.7', text: 'Concrete canopy - 2.0 kPa', qk: 2.0 }
            ],
            '8': [
                { value: '8.1', text: 'Window hoods - 2.0 kPa', qk: 2.0 },
                { value: '8.2', text: 'Utility platforms - 4.0 kPa', qk: 4.0 },
                { value: '8.3', text: 'Balconies - 3.0 kPa', qk: 3.0 },
                { value: '8.4', text: 'Stairs and corridors - 4.0 kPa', qk: 4.0 },
                { value: '8.5', text: 'Maintenance catwalks - 1.0 kPa', qk: 1.0 }
            ]
        };

        // Exposure covers data - per HK Code Table 4.1 (extended for higher concrete grades)
        const covers = {
            '1': {25:35, 30:30, 35:30, 40:30, 45:25, 50:25, 55:25, 60:25},
            '2': {25:40, 30:35, 35:35, 40:35, 45:30, 50:30, 55:30, 60:30},
            '3': {25:50, 30:50, 35:50, 40:50, 45:45, 50:45, 55:45, 60:45},
            '4': {25:60, 30:60, 35:55, 40:55, 45:50, 50:50, 55:50, 60:50},
            '5': {25:65, 30:65, 35:60, 40:60, 45:55, 50:55, 55:55, 60:55}
        };

        let globalData = {};
        let currentFramingData = null;
        let detailedCalculations = [];

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            updateSubDivisions();
            initializeCanvases();
            
            // Add event listeners for live load selection
            document.getElementById('liveLoad').addEventListener('change', updateSubDivisions);
            document.getElementById('liveLoadSub').addEventListener('change', updateHeightInput);
            
            // Add input event listeners for real-time validation
            document.getElementById('bayX').addEventListener('change', function() {
                const bayX = parseFloat(this.value);
                const maxSpan = document.getElementById('maxSpan');
                
                // Auto-update max span for convenience
                if (parseFloat(maxSpan.value) === 0 || parseFloat(maxSpan.value) > bayX) {
                    maxSpan.value = bayX.toFixed(1);
                }
            });
        });

        // Initialize canvases with proper sizing
        function initializeCanvases() {
            const canvas = document.getElementById('framingChart');
            if (canvas) {
                const container = canvas.parentElement;
                canvas.width = Math.min(container.clientWidth - 30, 800);
                canvas.height = Math.min(400, container.clientWidth * 0.6);
            }
        }

        window.addEventListener('resize', initializeCanvases);

        function updateSubDivisions() {
            const liveLoad = document.getElementById('liveLoad').value;
            const subDivSelect = document.getElementById('liveLoadSub');
            
            // Clear existing options
            subDivSelect.innerHTML = '<option value="">Select Sub-Division</option>';
            
            if (liveLoad && subDivisions[liveLoad]) {
                subDivisions[liveLoad].forEach(sub => {
                    const option = document.createElement('option');
                    option.value = sub.value;
                    option.text = sub.text;
                    option.dataset.isHeight = sub.isHeight || false;
                    option.dataset.perM = sub.perM || 0;
                    option.dataset.min = sub.min || 0;
                    option.dataset.qk = sub.qk || 0;
                    subDivSelect.appendChild(option);
                });
                
                // Auto-select the first option
                if (subDivisions[liveLoad].length > 0) {
                    subDivSelect.value = subDivisions[liveLoad][0].value;
                }
            }
            updateHeightInput();
        }

        function updateHeightInput() {
            const liveLoadSubSelect = document.getElementById('liveLoadSub');
            const selectedOption = liveLoadSubSelect.options[liveLoadSubSelect.selectedIndex];
            const heightInput = document.getElementById('heightInput');
            
            if (selectedOption && selectedOption.value) {
                const isHeight = selectedOption.dataset.isHeight === 'true';
                heightInput.style.display = isHeight ? 'block' : 'none';
            } else {
                heightInput.style.display = 'none';
            }
        }

        function getCover(exposure, fcu) {
            const table = covers[exposure];
            return table && table[fcu] ? table[fcu] : 35; // Default to 35mm if not found
        }

        // Tab switching function
        function switchTab(tabName) {
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => tab.classList.remove('active'));
            
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            
            // Find and activate the clicked tab
            const clickedTab = event.currentTarget;
            if (clickedTab) {
                clickedTab.classList.add('active');
            }
        }

        // Input Validation
        function validateInputs() {
            const bayX = parseFloat(document.getElementById('bayX').value);
            const bayY = parseFloat(document.getElementById('bayY').value);
            const maxSpan = parseFloat(document.getElementById('maxSpan').value);
            const deadLoad = parseFloat(document.getElementById('deadLoad').value);
            const floors = parseInt(document.getElementById('floors').value);
            const liveLoadClass = document.getElementById('liveLoad').value;
            const liveLoadSub = document.getElementById('liveLoadSub').value;
            
            if (!bayX || !bayY || !maxSpan || !deadLoad || !floors) {
                alert("Please fill in all required fields");
                return false;
            }
            
            if (bayX <= 0 || bayY <= 0) {
                alert("Bay dimensions must be positive values");
                return false;
            }
            
            if (!liveLoadClass || !liveLoadSub) {
                alert("Please select live load class and sub-division");
                return false;
            }
            
            if (maxSpan > Math.max(bayX, bayY)) {
                alert("Maximum slab span cannot exceed bay dimensions");
                return false;
            }
            
            return true;
        }

        // Enhanced Calculation Functions
        function calculateDetailedSlab(data) {
            const { Lslab, slabType, w, fcuSlab, coverSlab, minRhoSlab } = data;
            
            detailedCalculations.push({
                title: "SLAB DESIGN CALCULATIONS",
                steps: []
            });
            
            const slabCalc = detailedCalculations[detailedCalculations.length - 1];
            
            // Step 1: Determine basic span/depth ratio per Table 7.4
            slabCalc.steps.push({
                description: "Determine basic span/depth ratio from Table 7.4",
                calculation: `Basic span/depth ratio for ${slabType} slab = ${slabType === 'one-way' ? 26 : 30}`,
                reference: "HK Code 2013 - Table 7.4"
            });
            
            const basicRatio = slabType === 'one-way' ? 26 : 30;
            
            // Step 2: Calculate minimum slab thickness
            let hSlab = Math.ceil((Lslab * 1000) / basicRatio);
            slabCalc.steps.push({
                description: "Calculate minimum slab thickness",
                calculation: `h_min = L / ${basicRatio} = ${(Lslab * 1000).toFixed(0)} / ${basicRatio} = ${hSlab} mm`,
                reference: "HK Code 2013 - Clause 7.3.1.1"
            });
            
            // Step 3: Check absolute minimum thickness
            const absoluteMinThickness = Math.max(125, Lslab * 1000 / 40);
            if (hSlab < absoluteMinThickness) {
                slabCalc.steps.push({
                    description: "Apply absolute minimum thickness",
                    calculation: `Absolute minimum = max(125mm, L/40) = max(125, ${(Lslab*1000).toFixed(0)}/40) = ${absoluteMinThickness} mm`,
                    reference: "HK Code 2013 - Clause 7.3.1.1"
                });
                hSlab = Math.ceil(absoluteMinThickness);
            }
            
            // Step 4: Serviceability check - modify basic ratio
            const serviceStress = 0.9 * (fcuSlab * 1000 / hSlab);
            const modificationFactor = 0.55 + (477 - serviceStress) / (120 * (0.9 + 0.1));
            const allowableRatio = basicRatio * Math.min(2, modificationFactor);
            
            slabCalc.steps.push({
                description: "Calculate serviceability modification factor",
                calculation: `Modification factor = 0.55 + (477 - ${serviceStress.toFixed(0)})/(120×(0.9+0.1)) = ${modificationFactor.toFixed(2)}`,
                reference: "HK Code 2013 - Clause 7.3.1.2"
            });
            
            // Step 5: Check deflection
            const deflectionRatio = (Lslab * 1000) / hSlab;
            let deflectionOK = true;
            
            if (deflectionRatio > allowableRatio) {
                deflectionOK = false;
                slabCalc.steps.push({
                    description: "Increase slab thickness for deflection control",
                    calculation: `Required: L/h ≤ ${allowableRatio.toFixed(1)} (modified), Actual: ${deflectionRatio.toFixed(1)} = NG`,
                    reference: "HK Code 2013 - Clause 7.3.1.1"
                });
                hSlab = Math.ceil((Lslab * 1000) / allowableRatio);
            } else {
                slabCalc.steps.push({
                    description: "Check span/depth ratio for deflection",
                    calculation: `L/h = ${(Lslab * 1000).toFixed(0)} / ${hSlab} = ${deflectionRatio.toFixed(1)} ≤ ${allowableRatio.toFixed(1)} = OK`,
                    reference: "HK Code 2013 - Clause 7.3.1.1"
                });
            }
            
            // Step 6: Add cover and round up
            hSlab = Math.ceil((hSlab + coverSlab + 5) / 25) * 25;
            slabCalc.steps.push({
                description: "Add cover and round to nearest 25mm",
                calculation: `h_final = ${hSlab} mm (including ${coverSlab}mm cover)`,
                reference: "HK Code 2013 - Table 4.1"
            });
            
            // Step 7: Calculate self-weight
            const selfSlab = (hSlab / 1000) * CONCRETE_DENSITY;
            slabCalc.steps.push({
                description: "Calculate self-weight of slab",
                calculation: `Self-weight = (${hSlab}/1000) × ${CONCRETE_DENSITY} = ${selfSlab.toFixed(2)} kPa`,
                reference: `Concrete density = ${CONCRETE_DENSITY} kN/m³`
            });
            
            // Step 8: Calculate design moment for slab
            const moment = slabType === 'one-way' ? 
                w * Math.pow(Lslab, 2) / 8 : // One-way slab
                w * Math.pow(Lslab, 2) / 10; // Two-way slab (approx.)
                
            slabCalc.steps.push({
                description: "Calculate design moment",
                calculation: `M = ${w.toFixed(2)} × ${Lslab}² / ${slabType === 'one-way' ? 8 : 10} = ${moment.toFixed(2)} kNm/m`,
                reference: `${slabType === 'one-way' ? 'One-way' : 'Two-way'} slab moment`
            });
            
            // Step 9: Check minimum reinforcement
            const minReinforcementArea = 0.0013 * 1000 * hSlab; // mm²/m
            slabCalc.steps.push({
                description: "Check minimum reinforcement area",
                calculation: `A_s,min = 0.13% × 1000 × ${hSlab} = ${minReinforcementArea.toFixed(0)} mm²/m`,
                reference: "HK Code 2013 - Clause 9.3.1.1"
            });
            
            return { 
                hSlab, 
                selfSlab, 
                deflectionRatio,
                deflectionOK,
                moment: parseFloat(moment.toFixed(2)),
                minReinforcementArea: minReinforcementArea
            };
        }

        function calculateBeam(data, beamType) {
            const { Lbeam, load, fcuBeam, coverBeam, minRhoBeam, maxRhoBeam } = data;
            
            detailedCalculations.push({
                title: `${beamType.toUpperCase()} BEAM DESIGN CALCULATIONS`,
                steps: []
            });
            
            const beamCalc = detailedCalculations[detailedCalculations.length - 1];
            
            // Step 1: Determine basic span/depth ratio
            beamCalc.steps.push({
                description: "Determine basic span/depth ratio for beams",
                calculation: "Basic span/depth ratio = 18 (typical for simply supported beams)",
                reference: "HK Code 2013 - Table 7.4"
            });
            
            const basicRatio = 18;
            
            // Step 2: Calculate minimum beam depth for deflection
            let hBeam = Math.max(300, Math.ceil((Lbeam * 1000) / basicRatio));
            beamCalc.steps.push({
                description: "Calculate minimum beam depth for deflection",
                calculation: `h_min = max(300mm, L/${basicRatio}) = max(300, ${(Lbeam * 1000).toFixed(0)}/${basicRatio}) = ${hBeam} mm`,
                reference: "HK Code 2013 - Clause 7.3.1.1"
            });
            
            // Step 3: Initial beam width
            let bBeam = Math.max(250, Math.round(hBeam / 2 / 25) * 25);
            let iteration = 0;
            let shearOK = false;
            let V_capacity = 0;
            let shear = 0;
            let moment = 0;
            let selfWeightBeam = 0;
            let totalLoad = 0;
            let effectiveDepth = 0;
            let shearReinforcementRequired = false;
            let shearReinforcementArea = 0;
            let linkSpacing = 0;
            let maxSizeReached = false;
            
            beamCalc.steps.push({
                description: "Initial beam sizing",
                calculation: `Starting size: ${bBeam} × ${hBeam} mm for L = ${Lbeam}m, Load = ${load.toFixed(2)} kN/m`,
                reference: "Starting point"
            });
            
            // Try to find beam size that satisfies shear WITHOUT reinforcement first
            while (!shearOK && iteration < 15 && !maxSizeReached) {
                iteration++;
                
                // Recalculate everything for new dimensions
                selfWeightBeam = (bBeam / 1000) * (hBeam / 1000) * CONCRETE_DENSITY;
                totalLoad = load + selfWeightBeam;
                moment = totalLoad * Math.pow(Lbeam, 2) / 8;
                shear = totalLoad * Lbeam / 2;
                
                // Calculate effective depth
                effectiveDepth = hBeam - coverBeam - 10 - 16/2; // cover + link + bar/2
                if (effectiveDepth < 250) effectiveDepth = 250;
                
                // Calculate minimum reinforcement area and ratio
                const As_min = (minRhoBeam / 100) * bBeam * effectiveDepth;
                const ρ = As_min / (bBeam * effectiveDepth);
                
                // Apply HK Code limits for shear calculation
                const rhoFactor = Math.min(100 * ρ, 3);
                const depthFactor = Math.pow(400 / Math.max(effectiveDepth, 250), 0.25);
                const fcuFactor = Math.pow(Math.min(fcuBeam, 40) / 25, 1/3);
                
                // v_c per HK Code Clause 6.1.2.4
                const v_c = 0.79 * Math.pow(rhoFactor, 1/3) * depthFactor * fcuFactor / 1.25;
                V_capacity = v_c * bBeam * effectiveDepth / 1000; // kN
                
                const shearRatio = shear / V_capacity;
                
                if (shear > V_capacity) {
                    // Determine how much shear capacity is missing
                    const shearDeficit = shear - V_capacity;
                    const requiredV_c = shear * 1.1; // Aim for 10% above design shear
                    
                    if (iteration <= 10) {
                        beamCalc.steps.push({
                            description: `Iteration ${iteration}: Increasing beam size`,
                            calculation: `Size: ${bBeam}×${hBeam}mm, V=${shear.toFixed(1)}kN, V_c=${V_capacity.toFixed(1)}kN, Ratio=${shearRatio.toFixed(2)}`,
                            reference: "Increasing dimensions..."
                        });
                        
                        // Calculate required increase more intelligently
                        const requiredIncreaseFactor = requiredV_c / V_capacity;
                        
                        if (requiredIncreaseFactor > 2.5) {
                            // Very severe - increase both dimensions significantly
                            hBeam = Math.min(1200, hBeam + 200);
                            bBeam = Math.min(600, bBeam + 100);
                        } else if (requiredIncreaseFactor > 2.0) {
                            hBeam = Math.min(1200, hBeam + 150);
                            bBeam = Math.min(600, bBeam + 75);
                        } else if (requiredIncreaseFactor > 1.5) {
                            hBeam = Math.min(1200, hBeam + 100);
                            bBeam = Math.min(600, bBeam + 50);
                        } else {
                            hBeam = Math.min(1200, hBeam + 75);
                            if (hBeam / bBeam > 3) bBeam = Math.min(600, bBeam + 25);
                        }
                        
                        // Round to nearest 25mm
                        hBeam = Math.ceil(hBeam / 25) * 25;
                        bBeam = Math.ceil(bBeam / 25) * 25;
                        
                        // Check if we've reached maximum practical size
                        if (hBeam >= 1200 && bBeam >= 600) {
                            maxSizeReached = true;
                            beamCalc.steps.push({
                                description: "Maximum practical beam size reached",
                                calculation: `Maximum size: ${bBeam} × ${hBeam} mm`,
                                reference: "Will design shear reinforcement"
                            });
                        }
                    } else {
                        // After 10 iterations, consider shear reinforcement
                        maxSizeReached = true;
                        beamCalc.steps.push({
                            description: "Maximum iterations reached",
                            calculation: `After ${iteration} iterations: V=${shear.toFixed(1)}kN, V_c=${V_capacity.toFixed(1)}kN`,
                            reference: "Will design shear reinforcement"
                        });
                    }
                } else {
                    shearOK = true;
                    beamCalc.steps.push({
                        description: `Iteration ${iteration}: Shear capacity adequate`,
                        calculation: `Final size: ${bBeam}×${hBeam}mm, V=${shear.toFixed(1)}kN ≤ V_c=${V_capacity.toFixed(1)}kN, Ratio=${shearRatio.toFixed(2)} ✓`,
                        reference: "HK Code 2013 - Clause 6.1.2.4"
                    });
                }
            }
            
            // If we couldn't achieve shear capacity with concrete alone, design shear reinforcement
            if (!shearOK && maxSizeReached) {
                beamCalc.steps.push({
                    description: "DESIGNING SHEAR REINFORCEMENT",
                    calculation: "Concrete shear capacity insufficient - designing shear reinforcement",
                    reference: "HK Code 2013 - Clause 6.1.2.4"
                });
                
                // Calculate required shear reinforcement
                const V_s = shear - V_capacity; // Shear to be resisted by links
                
                // A_sw/s = V_s × 10^3 / (0.87 × f_yv × d)
                shearReinforcementArea = (V_s * 1000) / (0.87 * LINK_YIELD_STRENGTH * effectiveDepth); // mm² per m
                
                // Minimum shear reinforcement per Clause 6.1.2.5
                const A_sw_min = (0.4 * bBeam) / (0.87 * LINK_YIELD_STRENGTH); // mm² per m
                
                shearReinforcementArea = Math.max(shearReinforcementArea, A_sw_min);
                shearReinforcementRequired = true;
                
                // Calculate practical link spacing
                const linkDiameter = 10; // T10 links typical
                const areaPerLink = Math.PI * Math.pow(linkDiameter/2, 2) * 2; // 2 legs
                const requiredSpacing = (areaPerLink * 1000) / shearReinforcementArea;
                
                // Apply spacing limits
                const maxSpacing = Math.min(0.75 * effectiveDepth, 300);
                const minSpacing = 100;
                linkSpacing = Math.min(maxSpacing, Math.max(minSpacing, Math.round(requiredSpacing / 25) * 25));
                
                beamCalc.steps.push({
                    description: "Shear reinforcement calculation",
                    calculation: `V_s = V - V_c = ${shear.toFixed(1)} - ${V_capacity.toFixed(1)} = ${V_s.toFixed(1)} kN`,
                    reference: "Shear to be carried by links"
                });
                
                beamCalc.steps.push({
                    description: "Required shear reinforcement area",
                    calculation: `A_sw/s = ${shearReinforcementArea.toFixed(1)} mm²/m (Min: ${A_sw_min.toFixed(1)} mm²/m)`,
                    reference: "HK Code 2013 - Clause 6.1.2.5"
                });
                
                beamCalc.steps.push({
                    description: "Practical link arrangement",
                    calculation: `T${linkDiameter} links @ ${linkSpacing}mm c/c (2 legs)`,
                    reference: "Typical design"
                });
                
                // With reinforcement, shear is OK
                shearOK = true;
            }
            
            // Check if nominal shear reinforcement is needed even if V ≤ V_c
            if (shearOK && !shearReinforcementRequired) {
                shearReinforcementRequired = shear > (0.5 * V_capacity);
                if (shearReinforcementRequired) {
                    beamCalc.steps.push({
                        description: "Nominal shear reinforcement required",
                        calculation: `V = ${shear.toFixed(1)} kN > 0.5V_c = ${(0.5 * V_capacity).toFixed(1)} kN`,
                        reference: "HK Code 2013 - Clause 6.1.2.4(c)"
                    });
                    
                    // Calculate minimum shear reinforcement
                    const A_sw_min = (0.4 * bBeam) / (0.87 * LINK_YIELD_STRENGTH);
                    shearReinforcementArea = A_sw_min;
                    
                    // Suggest typical link arrangement
                    const linkDiameter = 10;
                    const areaPerLink = Math.PI * Math.pow(linkDiameter/2, 2) * 2;
                    const requiredSpacing = (areaPerLink * 1000) / shearReinforcementArea;
                    linkSpacing = Math.min(300, Math.max(100, Math.round(requiredSpacing / 25) * 25));
                    
                    beamCalc.steps.push({
                        description: "Minimum shear reinforcement",
                        calculation: `A_sw/s = ${A_sw_min.toFixed(1)} mm²/m (T${linkDiameter} @ ${linkSpacing}mm c/c)`,
                        reference: "HK Code 2013 - Clause 6.1.2.5"
                    });
                }
            }
            
            // Record final calculations
            beamCalc.steps.push({
                description: "Final beam dimensions",
                calculation: `Final: ${bBeam} × ${hBeam} mm ${maxSizeReached ? '(with shear reinforcement)' : ''}`,
                reference: "Design complete"
            });
            
            beamCalc.steps.push({
                description: "Final beam self-weight",
                calculation: `Self-weight = (${bBeam}/1000) × (${hBeam}/1000) × ${CONCRETE_DENSITY} = ${selfWeightBeam.toFixed(3)} kN/m`,
                reference: `Concrete density = ${CONCRETE_DENSITY} kN/m³`
            });
            
            beamCalc.steps.push({
                description: "Final total design load",
                calculation: `w_total = ${load.toFixed(2)} + ${selfWeightBeam.toFixed(3)} = ${totalLoad.toFixed(2)} kN/m`,
                reference: "Including self-weight"
            });
            
            beamCalc.steps.push({
                description: "Final design moment",
                calculation: `M = wL²/8 = ${totalLoad.toFixed(2)} × ${Lbeam}² / 8 = ${moment.toFixed(2)} kNm`,
                reference: "Simply supported beam moment"
            });
            
            beamCalc.steps.push({
                description: "Final design shear",
                calculation: `V = wL/2 = ${totalLoad.toFixed(2)} × ${Lbeam} / 2 = ${shear.toFixed(2)} kN`,
                reference: "Simply supported beam shear"
            });
            
            beamCalc.steps.push({
                description: "Final concrete shear capacity",
                calculation: `V_c = ${V_capacity.toFixed(1)} kN, V/V_c ratio = ${(shear/V_capacity).toFixed(2)}`,
                reference: "HK Code 2013 - Clause 6.1.2.4"
            });
            
            if (shearReinforcementRequired) {
                beamCalc.steps.push({
                    description: "Shear reinforcement summary",
                    calculation: `Required: ${shearReinforcementArea.toFixed(1)} mm²/m ${linkSpacing ? `(T10 @ ${linkSpacing}mm c/c)` : ''}`,
                    reference: "HK Code 2013 - Clause 6.1.2.5"
                });
            }
            
            // Check maximum reinforcement
            const maxReinforcementArea = (maxRhoBeam / 100) * bBeam * hBeam;
            beamCalc.steps.push({
                description: "Check maximum reinforcement",
                calculation: `A_s,max = ${maxRhoBeam}% × ${bBeam} × ${hBeam} = ${maxReinforcementArea.toFixed(0)} mm²`,
                reference: "HK Code 2013 - Clause 9.3.1.1"
            });
            
            // Check minimum reinforcement
            const minReinforcementArea = (minRhoBeam / 100) * bBeam * hBeam;
            beamCalc.steps.push({
                description: "Check minimum reinforcement",
                calculation: `A_s,min = ${minRhoBeam}% × ${bBeam} × ${hBeam} = ${minReinforcementArea.toFixed(0)} mm²`,
                reference: "HK Code 2013 - Clause 9.3.1.1"
            });
            
            // Final dimensions with cover
            const finalH = Math.ceil((hBeam + coverBeam + 20) / 25) * 25;
            beamCalc.steps.push({
                description: "Final beam dimensions with cover",
                calculation: `Final: ${bBeam} × ${finalH} mm (including ${coverBeam}mm cover)`,
                reference: "HK Code 2013 - Table 4.1"
            });
            
            return { 
                hBeam: finalH, 
                bBeam, 
                moment: parseFloat(moment.toFixed(2)), 
                shear: parseFloat(shear.toFixed(2)),
                shearOK: shearOK,
                V_capacity: V_capacity,
                shearReinforcementRequired: shearReinforcementRequired,
                shearReinforcementArea: shearReinforcementArea,
                linkSpacing: linkSpacing,
                iterationCount: iteration,
                effectiveDepth: effectiveDepth,
                maxSizeReached: maxSizeReached
            };
        }

        function calculateColumn(data) {
            const { area, w, floors, fcuColumn, minRhoColumn } = data;
            
            detailedCalculations.push({
                title: "COLUMN DESIGN CALCULATIONS",
                steps: []
            });
            
            const columnCalc = detailedCalculations[detailedCalculations.length - 1];
            
            // Step 1: Calculate total axial load
            const N = w * area * floors;
            columnCalc.steps.push({
                description: "Calculate total axial load on column",
                calculation: `N = w × A × n = ${w.toFixed(2)} × ${area.toFixed(1)} × ${floors} = ${N.toFixed(0)} kN`,
                reference: "Tributary area method"
            });
            
            // Step 2: Calculate required column area (simplified per HK Code)
            const gamma_c = 1.5; // Concrete material factor
            const gamma_s = 1.05; // Steel material factor
            
            const Ac = (N * 1e3) / (0.45 * fcuColumn / gamma_c + 0.87 * STEEL_YIELD_STRENGTH / gamma_s * (minRhoColumn / 100));
            columnCalc.steps.push({
                description: "Calculate required concrete area",
                calculation: `A_c = N × 10³ / (0.45f_cu/γ_c + 0.87f_y/γ_s × ρ) = ${(N*1e3).toFixed(0)} / (0.45×${fcuColumn}/1.5 + 0.87×460/1.05×${minRhoColumn/100}) = ${Ac.toFixed(0)} mm²`,
                reference: "HK Code 2013 - Clause 9.3.1.1 (simplified)"
            });
            
            // Step 3: Determine column size
            let side = Math.ceil(Math.sqrt(Ac) / 25) * 25;
            columnCalc.steps.push({
                description: "Determine column dimensions",
                calculation: `Side = √${Ac.toFixed(0)} = ${Math.sqrt(Ac).toFixed(0)} mm → Round up to ${side} mm`,
                reference: "Square column, rounded to nearest 25mm"
            });
            
            // Step 4: Check minimum dimensions per Clause 9.5.1
            const minColumnSize = 200;
            if (side < minColumnSize) {
                side = minColumnSize;
                columnCalc.steps.push({
                    description: "Apply minimum column dimension",
                    calculation: `Minimum column dimension = ${minColumnSize} mm per Clause 9.5.1`,
                    reference: "HK Code 2013 - Clause 9.5.1"
                });
            }
            
            // Step 5: Check slenderness
            const effectiveHeight = 3000; // Assume standard story height
            const slenderness = effectiveHeight / side;
            let slender = slenderness > 15;
            
            columnCalc.steps.push({
                description: "Check column slenderness",
                calculation: `λ = ${effectiveHeight}/${side} = ${slenderness.toFixed(1)} ${slender ? '> 15 (slender column)' : '≤ 15 (short column)'}`,
                reference: "HK Code 2013 - Clause 6.2.1.1"
            });
            
            // Step 6: Check maximum reinforcement
            const maxReinforcementArea = 0.06 * side * side;
            columnCalc.steps.push({
                description: "Maximum reinforcement check",
                calculation: `A_s,max = 6% × ${side}² = ${maxReinforcementArea.toFixed(0)} mm²`,
                reference: "HK Code 2013 - Clause 9.5.2"
            });
            
            return { 
                side, 
                axialLoad: N,
                slender: slender,
                slenderness: slenderness
            };
        }

        // MAIN CALCULATION FUNCTION
        async function calculateFraming() {
            try {
                document.body.classList.add('loading');
                document.getElementById('calculateBtn').textContent = 'Calculating...';
                
                if (!validateInputs()) {
                    document.body.classList.remove('loading');
                    document.getElementById('calculateBtn').textContent = 'Calculate Framing Plan';
                    return;
                }

                // Reset detailed calculations
                detailedCalculations = [];
                
                // Get input values
                const bayX = parseFloat(document.getElementById('bayX').value);
                const bayY = parseFloat(document.getElementById('bayY').value);
                const maxSpan = parseFloat(document.getElementById('maxSpan').value);
                const slabType = document.getElementById('slabType').value;
                const spanDirection = document.getElementById('spanDirection').value;
                const liveLoadClass = document.getElementById('liveLoad').value;
                const liveLoadSub = document.getElementById('liveLoadSub').value;
                const deadLoad = parseFloat(document.getElementById('deadLoad').value);
                const exposure = document.getElementById('exposure').value;
                const fcuSlab = parseInt(document.getElementById('concreteSlab').value);
                const fcuBeam = parseInt(document.getElementById('concreteBeam').value);
                const fcuColumn = parseInt(document.getElementById('concreteColumn').value);
                const minRhoSlab = parseFloat(document.getElementById('minReinforcementSlab').value);
                const minRhoBeam = parseFloat(document.getElementById('minReinforcementBeam').value);
                const maxRhoBeam = parseFloat(document.getElementById('maxReinforcementBeam').value);
                const minRhoColumn = parseFloat(document.getElementById('minReinforcement').value);
                const floors = parseInt(document.getElementById('floors').value);
                const height = parseFloat(document.getElementById('height').value) || 0;

                // Get live load value from selected option
                const liveLoadSubSelect = document.getElementById('liveLoadSub');
                const selectedOption = liveLoadSubSelect.options[liveLoadSubSelect.selectedIndex];
                let qk = 0;
                let subText = '';
                
                if (selectedOption) {
                    subText = selectedOption.text;
                    
                    // Check if it's a height-dependent load
                    if (selectedOption.dataset.isHeight === 'true') {
                        const perM = parseFloat(selectedOption.dataset.perM) || 0;
                        const minVal = parseFloat(selectedOption.dataset.min) || 0;
                        qk = perM * height;
                        if (minVal > 0) {
                            qk = Math.max(qk, minVal);
                        }
                    } else {
                        qk = parseFloat(selectedOption.dataset.qk) || 0;
                    }
                }
                
                globalData.qk = qk;

                // Get cover values per Table 4.1
                const coverSlab = getCover(exposure, fcuSlab);
                const coverBeam = getCover(exposure, fcuBeam);
                const coverColumn = getCover(exposure, fcuColumn);

                // Add loading calculations
                detailedCalculations.push({
                    title: "LOAD CALCULATIONS",
                    steps: [
                        {
                            description: "Determine imposed load from Code of Practice",
                            calculation: `q_k = ${qk} kPa (${subText})`,
                            reference: "HK Code 2011 - Table 3.2"
                        },
                        {
                            description: "Superimposed dead load",
                            calculation: `g_k = ${deadLoad} kPa`,
                            reference: "User specified"
                        },
                        {
                            description: "Load factors per Table 2.1",
                            calculation: "γ_g = 1.4 (dead load), γ_q = 1.6 (imposed load)",
                            reference: "HK Code 2013 - Table 2.1"
                        },
                        {
                            description: "Concrete density",
                            calculation: `γ_concrete = ${CONCRETE_DENSITY} kN/m³`,
                            reference: "Reinforced concrete density"
                        }
                    ]
                });

                // Determine slab span and secondary beams
                let Lslab = spanDirection === 'alongX' ? bayX : bayY;
                let Lother = spanDirection === 'alongX' ? bayY : bayX;
                let numberSpaces = 1;
                
                if (slabType === 'one-way' && Lslab > maxSpan) {
                    numberSpaces = Math.ceil(Lslab / maxSpan);
                    Lslab = Lslab / numberSpaces;
                }
                
                const numberSecondary = numberSpaces - 1;
                const spacing = Lslab;

                // Initial slab calculation (without self-weight)
                let slabResult = calculateDetailedSlab({
                    Lslab, slabType, w: 0, fcuSlab, coverSlab, minRhoSlab
                });

                // Update loading with slab self-weight
                const dl = slabResult.selfSlab + deadLoad;
                const w = 1.4 * dl + 1.6 * qk;

                // Add final load calculation
                detailedCalculations[0].steps.push(
                    {
                        description: "Slab self-weight",
                        calculation: `Slab self-weight = ${slabResult.selfSlab.toFixed(2)} kPa`,
                        reference: `Concrete density = ${CONCRETE_DENSITY} kN/m³`
                    },
                    {
                        description: "Total dead load",
                        calculation: `g_total = ${slabResult.selfSlab.toFixed(2)} + ${deadLoad} = ${dl.toFixed(2)} kPa`,
                        reference: "Sum of self-weight and superimposed dead load"
                    },
                    {
                        description: "Design load (ULS)",
                        calculation: `w = 1.4g + 1.6q = 1.4×${dl.toFixed(2)} + 1.6×${qk} = ${w.toFixed(2)} kPa`,
                        reference: "HK Code 2013 - Clause 3.2.1.2"
                    }
                );

                // Recalculate slab with actual loads
                slabResult = calculateDetailedSlab({
                    Lslab, slabType, w, fcuSlab, coverSlab, minRhoSlab
                });

                // Secondary beam calculation
                const beamLoad = w * spacing;
                const secondaryBeamResult = calculateBeam({
                    Lbeam: Lother,
                    load: beamLoad,
                    fcuBeam,
                    coverBeam,
                    minRhoBeam,
                    maxRhoBeam
                }, "Secondary");

                // Main beam calculation
                const mainBeamResult = calculateBeam({
                    Lbeam: bayX,
                    load: w * (spanDirection === 'alongX' ? bayY : bayX),
                    fcuBeam,
                    coverBeam,
                    minRhoBeam,
                    maxRhoBeam
                }, "Main");

                // Column calculation
                const area = bayX * bayY;
                const columnResult = calculateColumn({
                    area, w, floors, fcuColumn, minRhoColumn
                });

                // Store framing data
                currentFramingData = {
                    bayX: bayX,
                    bayY: bayY,
                    spacing: spacing,
                    numberSecondary: numberSecondary,
                    spanDirection: spanDirection,
                    hSlab: slabResult.hSlab,
                    bBeamSecondary: secondaryBeamResult.bBeam,
                    hBeamSecondary: secondaryBeamResult.hBeam,
                    bBeamMain: mainBeamResult.bBeam,
                    hBeamMain: mainBeamResult.hBeam,
                    side: columnResult.side,
                    slabMoment: slabResult.moment,
                    secondaryBeamMoment: secondaryBeamResult.moment,
                    secondaryBeamShear: secondaryBeamResult.shear,
                    mainBeamMoment: mainBeamResult.moment,
                    mainBeamShear: mainBeamResult.shear,
                    columnLoad: columnResult.axialLoad,
                    slabDeflectionOK: slabResult.deflectionOK,
                    secondaryShearOK: secondaryBeamResult.shearOK,
                    mainShearOK: mainBeamResult.shearOK,
                    columnSlender: columnResult.slender,
                    secondaryShearReinforcement: secondaryBeamResult.shearReinforcementRequired,
                    mainShearReinforcement: mainBeamResult.shearReinforcementRequired,
                    secondaryVCapacity: secondaryBeamResult.V_capacity,
                    mainVCapacity: mainBeamResult.V_capacity,
                    secondaryIterations: secondaryBeamResult.iterationCount,
                    mainIterations: mainBeamResult.iterationCount,
                    secondaryLinkSpacing: secondaryBeamResult.linkSpacing,
                    mainLinkSpacing: mainBeamResult.linkSpacing,
                    secondaryMaxSizeReached: secondaryBeamResult.maxSizeReached,
                    mainMaxSizeReached: mainBeamResult.maxSizeReached
                };

                // Update summary table - FIXED: Removed *100 multiplication for minRhoSlab
                const summaryTableBody = document.getElementById('summaryTableBody');
                summaryTableBody.innerHTML = `
                    <tr>
                        <td>Slab</td>
                        <td>${slabResult.hSlab} mm</td>
                        <td>Min: ${minRhoSlab}%</td>
                        <td>${slabResult.moment} kNm/m</td>
                        <td>-</td>
                        <td class="${slabResult.deflectionOK ? 'status-ok' : 'status-warning'}">${slabResult.deflectionOK ? '✓' : '⚠️ Deflection'}</td>
                    </tr>
                    <tr>
                        <td>Secondary Beam</td>
                        <td>${secondaryBeamResult.bBeam} × ${secondaryBeamResult.hBeam} mm</td>
                        <td>${minRhoBeam}% min</td>
                        <td>${secondaryBeamResult.moment}</td>
                        <td>${secondaryBeamResult.shear}</td>
                        <td class="${secondaryBeamResult.shearOK ? 
                            (secondaryBeamResult.shearReinforcementRequired ? 'status-info' : 'status-ok') : 
                            'status-error'}">
                            ${secondaryBeamResult.shearOK ? 
                                (secondaryBeamResult.shearReinforcementRequired ? 
                                    (secondaryBeamResult.maxSizeReached ? '✓ (Designed Links)' : '✓ (Nominal Links)') : 
                                    '✓') : 
                                '✗ Shear'}
                            <span class="iteration-info">V_c: ${secondaryBeamResult.V_capacity.toFixed(1)} kN${secondaryBeamResult.linkSpacing ? `, T10@${secondaryBeamResult.linkSpacing}mm` : ''}</span>
                        </td>
                    </tr>
                    <tr>
                        <td>Main Beam</td>
                        <td>${mainBeamResult.bBeam} × ${mainBeamResult.hBeam} mm</td>
                        <td>${minRhoBeam}% min</td>
                        <td>${mainBeamResult.moment}</td>
                        <td>${mainBeamResult.shear}</td>
                        <td class="${mainBeamResult.shearOK ? 
                            (mainBeamResult.shearReinforcementRequired ? 'status-info' : 'status-ok') : 
                            'status-error'}">
                            ${mainBeamResult.shearOK ? 
                                (mainBeamResult.shearReinforcementRequired ? 
                                    (mainBeamResult.maxSizeReached ? '✓ (Designed Links)' : '✓ (Nominal Links)') : 
                                    '✓') : 
                                '✗ Shear'}
                            <span class="iteration-info">V_c: ${mainBeamResult.V_capacity.toFixed(1)} kN${mainBeamResult.linkSpacing ? `, T10@${mainBeamResult.linkSpacing}mm` : ''}</span>
                        </td>
                    </tr>
                    <tr>
                        <td>Column</td>
                        <td>${columnResult.side} × ${columnResult.side} mm</td>
                        <td>${minRhoColumn}% min</td>
                        <td>-</td>
                        <td>${columnResult.axialLoad.toFixed(0)} kN</td>
                        <td class="${columnResult.slender ? 'status-warning' : 'status-ok'}">${columnResult.slender ? '⚠️ Slender' : '✓'}</td>
                    </tr>
                `;

                // Update calculations display
                displayDetailedCalculations();

                // Draw the framing plan
                drawFramingPlan(currentFramingData);

            } catch (error) {
                console.error('Calculation error:', error);
                alert('Calculation failed: ' + error.message);
            } finally {
                document.body.classList.remove('loading');
                document.getElementById('calculateBtn').textContent = 'Calculate Framing Plan';
            }
        }

        function displayDetailedCalculations() {
            const calculationStepsDiv = document.getElementById('calculationSteps');
            let html = '';
            
            detailedCalculations.forEach(section => {
                html += `<h4>${section.title}</h4>`;
                section.steps.forEach(step => {
                    html += `
                        <div class="calculation-step">
                            <div><strong>${step.description}</strong></div>
                            <div class="formula">${step.calculation}</div>
                            <div class="code-reference">Reference: ${step.reference}</div>
                        </div>
                    `;
                });
                html += '<hr>';
            });
            
            calculationStepsDiv.innerHTML = html;
        }

        // Improved framing plan drawing function
        function drawFramingPlan(data) {
            const canvas = document.getElementById('framingChart');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const scale = Math.min(canvas.width - 100, canvas.height - 150) / Math.max(data.bayX, data.bayY);
            const offsetX = 50;
            const offsetY = 50;
            
            // Draw bay grid
            const width = data.bayX * scale;
            const height = data.bayY * scale;
            
            // Draw slab area
            ctx.fillStyle = 'rgba(189, 195, 199, 0.3)';
            ctx.fillRect(offsetX, offsetY, width, height);
            
            // Draw columns
            const colSize = Math.min(15, data.side / 100 * 5);
            ctx.fillStyle = '#c0392b';
            
            // Four corners
            ctx.fillRect(offsetX - colSize/2, offsetY - colSize/2, colSize, colSize);
            ctx.fillRect(offsetX + width - colSize/2, offsetY - colSize/2, colSize, colSize);
            ctx.fillRect(offsetX - colSize/2, offsetY + height - colSize/2, colSize, colSize);
            ctx.fillRect(offsetX + width - colSize/2, offsetY + height - colSize/2, colSize, colSize);
            
            // Draw beams
            ctx.strokeStyle = '#3498db';
            const mainBeamThickness = Math.max(3, data.hBeamMain / 150);
            ctx.lineWidth = mainBeamThickness;
            
            // Main beams
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            ctx.lineTo(offsetX + width, offsetY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY + height);
            ctx.lineTo(offsetX + width, offsetY + height);
            ctx.stroke();
            
            // Secondary beams if present
            if (data.numberSecondary > 0) {
                ctx.strokeStyle = '#2980b9';
                const secBeamThickness = Math.max(2, data.hBeamSecondary / 150);
                ctx.lineWidth = secBeamThickness;
                
                const spacing = width / (data.numberSecondary + 1);
                for (let i = 1; i <= data.numberSecondary; i++) {
                    const x = offsetX + spacing * i;
                    ctx.beginPath();
                    ctx.moveTo(x, offsetY);
                    ctx.lineTo(x, offsetY + height);
                    ctx.stroke();
                }
            }
            
            // Add shear reinforcement indicators if needed
            if (data.mainShearReinforcement || data.secondaryShearReinforcement) {
                ctx.fillStyle = '#e74c3c';
                ctx.font = '10px Arial';
                if (data.mainShearReinforcement) {
                    ctx.fillText('Links required', offsetX + 10, offsetY - 15);
                }
                if (data.secondaryShearReinforcement) {
                    ctx.fillText('Links required', offsetX + width/2 - 20, offsetY + height + 20);
                }
            }
            
            // Add dimensions
            ctx.fillStyle = '#2c3e50';
            ctx.font = '12px Arial';
            ctx.fillText(`${data.bayX.toFixed(1)}m`, offsetX + width/2 - 15, offsetY - 10);
            ctx.fillText(`${data.bayY.toFixed(1)}m`, offsetX - 30, offsetY + height/2);
            
            // Legend
            const legendY = offsetY + height + 40;
            ctx.fillStyle = '#3498db';
            ctx.fillRect(offsetX, legendY, 15, 15);
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(`Main Beam: ${data.bBeamMain}×${data.hBeamMain}mm`, offsetX + 25, legendY + 12);
            
            ctx.fillStyle = '#2980b9';
            ctx.fillRect(offsetX, legendY + 25, 15, 15);
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(`Secondary Beam: ${data.bBeamSecondary}×${data.hBeamSecondary}mm`, offsetX + 25, legendY + 37);
            
            ctx.fillStyle = '#c0392b';
            ctx.fillRect(offsetX, legendY + 50, 15, 15);
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(`Column: ${data.side}×${data.side}mm`, offsetX + 25, legendY + 62);
            
            ctx.fillStyle = '#bdc3c7';
            ctx.fillRect(offsetX, legendY + 75, 15, 15);
            ctx.fillStyle = '#2c3e50';
            ctx.fillText(`Slab: ${data.hSlab}mm`, offsetX + 25, legendY + 87);
        }

        function exportResults() {
            if (!currentFramingData) {
                alert("No calculation results to export");
                return;
            }
            
            const data = {
                inputs: collectInputs(),
                results: currentFramingData,
                calculations: detailedCalculations,
                timestamp: new Date().toISOString(),
                version: '1.4',
                codeReferences: [
                    "Hong Kong Code of Practice for Structural Use of Concrete 2013 (2020 Edition)",
                    "Code of Practice for Dead and Imposed Loads 2011"
                ]
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {
                type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `framing-plan-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function generateReport() {
            if (!currentFramingData) {
                alert("No calculation results to report");
                return;
            }
            
            const inputs = collectInputs();
            const report = `
PRELIMINARY FRAMING PLAN REPORT - Version 1.4
==============================================

Project Details:
- Date: ${new Date().toDateString()}
- Bay Size: ${currentFramingData.bayX} m × ${currentFramingData.bayY} m
- Number of Floors: ${inputs.floors}
- Live Load: ${inputs.qk} kPa (${document.getElementById('liveLoadSub').options[document.getElementById('liveLoadSub').selectedIndex].text})
- Concrete Grades: Slab ${inputs.fcuSlab} MPa, Beam ${inputs.fcuBeam} MPa, Column ${inputs.fcuColumn} MPa
- Exposure Condition: ${document.getElementById('exposure').options[document.getElementById('exposure').selectedIndex].text}

DESIGN SUMMARY:
- Slab Thickness: ${currentFramingData.hSlab} mm ${currentFramingData.slabDeflectionOK ? '(Deflection OK)' : '(Deflection check failed)'}
- Main Beams: ${currentFramingData.bBeamMain} × ${currentFramingData.hBeamMain} mm ${currentFramingData.mainShearOK ? 
    (currentFramingData.mainShearReinforcement ? 
        (currentFramingData.mainMaxSizeReached ? '(Shear reinforcement designed)' : '(Nominal links required)') : 
        '(No shear reinforcement)') : 
    '(Shear check failed)'}
- Secondary Beams: ${currentFramingData.bBeamSecondary} × ${currentFramingData.hBeamSecondary} mm ${currentFramingData.secondaryShearOK ? 
    (currentFramingData.secondaryShearReinforcement ? 
        (currentFramingData.secondaryMaxSizeReached ? '(Shear reinforcement designed)' : '(Nominal links required)') : 
        '(No shear reinforcement)') : 
    '(Shear check failed)'}
- Columns: ${currentFramingData.side} × ${currentFramingData.side} mm ${currentFramingData.columnSlender ? '(Slender column)' : '(Short column)'}

LOADING:
- Superimposed Dead Load: ${inputs.deadLoad} kPa
- Imposed Load: ${inputs.qk} kPa
- Design Load (ULS): ${(1.4 * (currentFramingData.hSlab/1000 * CONCRETE_DENSITY + inputs.deadLoad) + 1.6 * inputs.qk).toFixed(2)} kPa

SHEAR CAPACITY CHECKS:
- Main Beam: V = ${currentFramingData.mainBeamShear} kN, V_c = ${currentFramingData.mainVCapacity.toFixed(1)} kN, Ratio = ${(currentFramingData.mainBeamShear/currentFramingData.mainVCapacity).toFixed(2)} ${currentFramingData.mainLinkSpacing ? `(Links: T10@${currentFramingData.mainLinkSpacing}mm)` : ''}
- Secondary Beam: V = ${currentFramingData.secondaryBeamShear} kN, V_c = ${currentFramingData.secondaryVCapacity.toFixed(1)} kN, Ratio = ${(currentFramingData.secondaryBeamShear/currentFramingData.secondaryVCapacity).toFixed(2)} ${currentFramingData.secondaryLinkSpacing ? `(Links: T10@${currentFramingData.secondaryLinkSpacing}mm)` : ''}

BEAM SIZING ITERATIONS:
- Main Beam: ${currentFramingData.mainIterations} iteration(s) ${currentFramingData.mainMaxSizeReached ? '(Max size reached)' : ''}
- Secondary Beam: ${currentFramingData.secondaryIterations} iteration(s) ${currentFramingData.secondaryMaxSizeReached ? '(Max size reached)' : ''}

CODE REFERENCES:
- Hong Kong Code of Practice for Structural Use of Concrete 2013 (2020 Edition)
- Loading: Code of Practice for Dead and Imposed Loads 2011

CALCULATION METHODOLOGY:
1. Slab design based on span/depth ratios per Table 7.4 with modification factors per Clause 7.3.1.2
2. Beam design with automatic iterative sizing for shear capacity per Clause 6.1.2.4
3. Shear reinforcement designed when concrete capacity insufficient per Clause 6.1.2.5
4. Column design based on tributary area and axial load capacity with slenderness check per Clause 6.2.1.1
5. Beam dimensions automatically increased until V ≤ V_c or maximum practical size reached
6. Shear reinforcement required when V > 0.5V_c per Clause 6.1.2.4(c)
7. All dimensions rounded up to nearest 25mm for practicality
8. Cover to reinforcement per Table 4.1 based on exposure condition

DESIGN CHECKS PERFORMED:
- Slab: Deflection control per Clause 7.3.1
- Beams: Automatic iterative sizing for shear capacity per Clause 6.1.2.4
- Shear reinforcement: Designed per Clause 6.1.2.5 when required
- Columns: Slenderness check per Clause 6.2.1.1
- Reinforcement: Minimum and maximum percentages per Clause 9.3.1.1

NOTES:
- This is a preliminary design for estimation purposes only
- Final design must be verified by qualified structural engineer
- Concrete density: ${CONCRETE_DENSITY} kN/m³
- Steel yield strength: ${STEEL_YIELD_STRENGTH} MPa
- Link steel yield strength: ${LINK_YIELD_STRENGTH} MPa
- Beam sizes automatically increased to satisfy shear capacity requirements
- Shear reinforcement designed when concrete capacity insufficient

Generated by Preliminary Framing Plan Calculator v1.4
            `;
            
            // Create printable report
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <html>
                    <head>
                        <title>Framing Plan Report</title>
                        <style>
                            body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; }
                            pre { white-space: pre-wrap; font-family: monospace; font-size: 14px; }
                            h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
                            .warning { color: #e74c3c; font-weight: bold; }
                            .check { color: #27ae60; }
                            .info { color: #3498db; }
                            @media print {
                                body { margin: 20px; }
                                h1 { font-size: 24px; }
                                pre { font-size: 12px; }
                            }
                        </style>
                    </head>
                    <body>
                        <h1>Preliminary Framing Plan Report</h1>
                        <pre>${report}</pre>
                        <div style="margin-top: 30px; font-size: 12px; color: #7f8c8d;">
                            <strong>Disclaimer:</strong> This is a preliminary design for estimation purposes only. 
                            Final design must be verified by a qualified structural engineer.
                        </div>
                        <div style="margin-top: 10px; font-size: 12px; color: #7f8c8d;">
                            <strong>Status Legend:</strong> 
                            <span style="color: #27ae60;">✓ = OK (No shear reinforcement needed)</span> | 
                            <span style="color: #3498db;">✓ (Nominal Links) = Minimum links required (V > 0.5V_c)</span> | 
                            <span style="color: #3498db;">✓ (Designed Links) = Designed shear reinforcement required (V > V_c)</span> | 
                            <span style="color: #e74c3c;">✗ Shear = Redesign needed</span> | 
                            <span style="color: #f39c12;">⚠️ = Warning</span>
                        </div>
                    </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        function collectInputs() {
            return {
                bayX: parseFloat(document.getElementById('bayX').value),
                bayY: parseFloat(document.getElementById('bayY').value),
                maxSpan: parseFloat(document.getElementById('maxSpan').value),
                slabType: document.getElementById('slabType').value,
                spanDirection: document.getElementById('spanDirection').value,
                liveLoadClass: document.getElementById('liveLoad').value,
                liveLoadSub: document.getElementById('liveLoadSub').value,
                deadLoad: parseFloat(document.getElementById('deadLoad').value),
                exposure: document.getElementById('exposure').value,
                fcuSlab: parseInt(document.getElementById('concreteSlab').value),
                fcuBeam: parseInt(document.getElementById('concreteBeam').value),
                fcuColumn: parseInt(document.getElementById('concreteColumn').value),
                minRhoSlab: parseFloat(document.getElementById('minReinforcementSlab').value),
                minRhoBeam: parseFloat(document.getElementById('minReinforcementBeam').value),
                maxRhoBeam: parseFloat(document.getElementById('maxReinforcementBeam').value),
                minRhoColumn: parseFloat(document.getElementById('minReinforcement').value),
                floors: parseInt(document.getElementById('floors').value),
                qk: globalData.qk || 0,
                timestamp: new Date().toISOString()
            };
        }
    </script>
</body>
</html>